/**
 * Workflow Engine Service - Complete Orchestrator (< 500 lines)
 * Integrates all workflow modules with comprehensive API
 */
import { PrismaClient } from '@prisma/client';
import { Result } from '../providers/ml-provider.interface';
import {
  WorkflowTemplate,
  WorkflowStep,
  WorkflowExecution,
  WorkflowEngineError,
  WorkflowStatus,
} from './workflow/types';
import { WorkflowValidator } from './workflow/validator';
import { HandlerRegistry } from './workflow/registry';
import { WorkflowMonitor } from './workflow/monitor';
import { TemplateManager } from './workflow/template-manager';
import { WorkflowExecutionManager } from './workflow/execution-manager';
import { WorkflowStepExecutor } from './workflow/step-executor';

export interface WorkflowEngineConfig {
  maxConcurrentExecutions?: number;
  defaultTimeout?: number;
  enableMonitoring?: boolean;
  retryDefaults?: {
    maxAttempts: number;
    backoffMs: number;
  };
}

/**
 * Main Workflow Engine Orchestrator
 * Coordinates all workflow operations through integrated modules
 */
export class WorkflowEngineService {
  private prisma: PrismaClient;
  private config: Required<WorkflowEngineConfig>;

  // Core modules
  private validator!: WorkflowValidator;
  private handlerRegistry!: HandlerRegistry;
  private monitor!: WorkflowMonitor;
  private templateManager!: TemplateManager;
  private executionManager!: WorkflowExecutionManager;
  private stepExecutor!: WorkflowStepExecutor;

  // Runtime state
  private runningExecutions = new Map<string, Promise<void>>();
  private initialized = false;

  constructor(prisma: PrismaClient, config: WorkflowEngineConfig = {}) {
    this.prisma = prisma;
    this.config = {
      maxConcurrentExecutions: config.maxConcurrentExecutions || 50,
      defaultTimeout: config.defaultTimeout || 300000, // 5 minutes
      enableMonitoring: config.enableMonitoring ?? true,
      retryDefaults: config.retryDefaults || {
        maxAttempts: 3,
        backoffMs: 1000,
      },
    };

    this.initializeModules();
  }

  /**
   * Initialize all workflow modules
   */
  private initializeModules(): void {
    this.validator = new WorkflowValidator();
    this.handlerRegistry = new HandlerRegistry();
    this.monitor = new WorkflowMonitor();

    this.templateManager = new TemplateManager(this.prisma);
    this.executionManager = new WorkflowExecutionManager(
      this.prisma,
      this.monitor,
      this.handlerRegistry
    );
    this.stepExecutor = new WorkflowStepExecutor(
      this.prisma,
      this.handlerRegistry,
      this.monitor
    );

    this.registerDefaultHandlers();
    this.initialized = true;
  }

  /**
   * Register default workflow handlers
   */
  private registerDefaultHandlers(): void {
    // Register built-in handlers
    this.handlerRegistry.register({
      name: 'delay',
      version: '1.0.0',
      description: 'Delays execution for specified duration',
      execute: async (input: { duration: number }) => {
        await new Promise(resolve =>
          setTimeout(resolve, input.duration || 1000)
        );
        return { success: true, output: { delayed: input.duration } };
      },
    });

    this.handlerRegistry.register({
      name: 'log',
      version: '1.0.0',
      description: 'Logs message to console',
      execute: async (input: { message: string; level?: string }) => {
        const level = input.level || 'info';
        (console as any)[level]?.(input.message) || console.log(input.message);
        return { success: true, output: { logged: input.message } };
      },
    });

    this.handlerRegistry.register({
      name: 'transform',
      version: '1.0.0',
      description: 'Transforms input data using provided mapping',
      execute: async (input: { data: any; mapping: Record<string, any> }) => {
        const result: any = {};
        for (const [key, path] of Object.entries(input.mapping)) {
          result[key] = this.getNestedValue(input.data, path as string);
        }
        return { success: true, output: result };
      },
    });
  }

  // ===== TEMPLATE MANAGEMENT API =====

  /**
   * Create workflow template
   */
  async createTemplate(
    name: string,
    description: string,
    steps: WorkflowStep[],
    metadata?: Record<string, any>
  ): Promise<Result<WorkflowTemplate, WorkflowEngineError>> {
    this.ensureInitialized();
    const template: WorkflowTemplate = {
      id: '', // Will be generated by database
      name,
      description,
      steps,
      metadata: metadata || {},
      version: '1.0.0',
      type: 'workflow',
      active: true,
    };
    return this.templateManager.createWorkflowTemplate(template);
  }

  /**
   * Update workflow template
   */
  async updateTemplate(
    templateId: string,
    updates: Partial<WorkflowTemplate>
  ): Promise<Result<WorkflowTemplate, WorkflowEngineError>> {
    this.ensureInitialized();
    return this.templateManager.updateWorkflowTemplate(templateId, updates);
  }

  /**
   * Delete workflow template
   */
  async deleteTemplate(
    templateId: string
  ): Promise<Result<boolean, WorkflowEngineError>> {
    this.ensureInitialized();
    const result = await this.templateManager.deleteWorkflowTemplate(
      templateId
    );
    if (!result.success) {
      return {
        success: false,
        error:
          'error' in result
            ? result.error
            : new WorkflowEngineError(
                'DELETE_FAILED',
                'Failed to delete template'
              ),
      };
    }

    return { success: true, data: true };
  }

  /**
   * Get workflow template by ID
   */
  async getTemplate(
    templateId: string
  ): Promise<Result<WorkflowTemplate, WorkflowEngineError>> {
    this.ensureInitialized();
    return this.templateManager.getWorkflowTemplate(templateId);
  }

  /**
   * List all workflow templates
   */
  async listTemplates(filters?: {
    category?: string;
    status?: 'active' | 'inactive';
    search?: string;
  }): Promise<Result<WorkflowTemplate[], WorkflowEngineError>> {
    this.ensureInitialized();
    const result = await this.templateManager.getWorkflowTemplates(filters);
    if (result.success) {
      return { success: true, data: result.data.templates };
    } else {
      return result as Result<WorkflowTemplate[], WorkflowEngineError>;
    }
  }

  // ===== EXECUTION MANAGEMENT API =====

  /**
   * Start workflow execution
   */
  async startExecution(
    templateId: string,
    input: Record<string, any>,
    options?: {
      priority?: number;
      timeout?: number;
      metadata?: Record<string, any>;
    }
  ): Promise<Result<string, WorkflowEngineError>> {
    this.ensureInitialized();

    // Check concurrent execution limits
    if (this.runningExecutions.size >= this.config.maxConcurrentExecutions) {
      return {
        success: false,
        error: new WorkflowEngineError(
          'MAX_CONCURRENT_EXECUTIONS_REACHED',
          `Maximum concurrent executions (${this.config.maxConcurrentExecutions}) reached`
        ),
      };
    }

    const executionOptions = {
      priority: 'medium' as const,
      timeout: options?.timeout,
      continueOnError: false,
    };

    const result = await this.executionManager.startExecution(
      templateId,
      input,
      executionOptions
    );

    if (result.success) {
      // Start execution monitoring in background
      const executionPromise = this.runWorkflowExecution(
        result.data.executionId
      );
      this.runningExecutions.set(result.data.executionId, executionPromise);

      return { success: true, data: result.data.executionId };
    }

    return {
      success: false,
      error:
        'error' in result
          ? result.error
          : new WorkflowEngineError('EXECUTION_FAILED', 'Execution failed'),
    };
  }

  /**
   * Pause workflow execution
   */
  async pauseExecution(
    executionId: string
  ): Promise<Result<boolean, WorkflowEngineError>> {
    this.ensureInitialized();
    return this.executionManager.pauseExecution(executionId);
  }

  /**
   * Resume workflow execution
   */
  async resumeExecution(
    executionId: string
  ): Promise<Result<boolean, WorkflowEngineError>> {
    this.ensureInitialized();
    const result = await this.executionManager.resumeExecution(executionId);

    if (result.success && !this.runningExecutions.has(executionId)) {
      // Restart execution monitoring
      const executionPromise = this.runWorkflowExecution(executionId);
      this.runningExecutions.set(executionId, executionPromise);
    }

    return result;
  }

  /**
   * Cancel workflow execution
   */
  async cancelExecution(
    executionId: string
  ): Promise<Result<boolean, WorkflowEngineError>> {
    this.ensureInitialized();

    // Stop monitoring
    this.runningExecutions.delete(executionId);

    return this.executionManager.cancelExecution(executionId);
  }

  /**
   * Get execution status
   */
  async getExecutionStatus(
    executionId: string
  ): Promise<Result<WorkflowExecution, WorkflowEngineError>> {
    this.ensureInitialized();
    return this.executionManager.getExecutionStatus(executionId);
  }

  /**
   * Get execution history
   */
  async getExecutionHistory(filters?: {
    templateId?: string;
    status?: WorkflowStatus;
    startDate?: Date;
    endDate?: Date;
    limit?: number;
  }): Promise<Result<WorkflowExecution[], WorkflowEngineError>> {
    this.ensureInitialized();
    return this.executionManager.getExecutionHistory(
      filters?.templateId,
      filters?.limit || 50,
      0
    );
  }

  // ===== HANDLER MANAGEMENT API =====

  /**
   * Register custom handler
   */
  registerHandler(handler: any): void {
    this.ensureInitialized();
    this.handlerRegistry.register(handler);
  }

  /**
   * Get registered handlers
   */
  getHandlers(): string[] {
    this.ensureInitialized();
    return this.handlerRegistry.list();
  }

  // ===== MONITORING & STATISTICS API =====

  /**
   * Get workflow execution statistics
   */
  async getStatistics(timeRange?: { start: Date; end: Date }): Promise<any> {
    this.ensureInitialized();
    // Return basic statistics for now - can be enhanced later
    return {
      activeExecutions: this.runningExecutions.size,
      totalHandlers: this.handlerRegistry.list().length,
      timeRange: timeRange || null,
    };
  }

  /**
   * Get active executions count
   */
  getActiveExecutionsCount(): number {
    return this.runningExecutions.size;
  }

  // ===== PRIVATE EXECUTION LOGIC =====

  /**
   * Execute workflow steps in sequence
   */
  private async runWorkflowExecution(executionId: string): Promise<void> {
    try {
      const statusResult = await this.executionManager.getExecutionStatus(
        executionId
      );
      if (!statusResult.success) return;

      const execution = statusResult.data;
      const templateResult = await this.templateManager.getWorkflowTemplate(
        execution.workflowId
      );
      if (!templateResult.success) return;

      const template = templateResult.data;

      // Execute steps sequentially
      for (const step of template.steps) {
        const stepResult = await this.stepExecutor.executeStep(
          step,
          {
            stepId: step.stepId,
            workflowRunId: executionId,
            input: execution.input,
            variables: execution.variables || {},
            metadata: (execution as any).metadata || {},
            attempt: 1,
            maxAttempts: step.retries || this.config.retryDefaults.maxAttempts,
          },
          {
            timeout: step.timeout || this.config.defaultTimeout,
            retryDelay: this.config.retryDefaults.backoffMs,
          }
        );

        if (!stepResult.success || !stepResult.data.shouldContinue) {
          break;
        }

        // Update execution variables
        if (stepResult.data.updatedVariables) {
          await this.updateExecutionVariables(
            executionId,
            stepResult.data.updatedVariables
          );
        }
      }
    } catch (error) {
      console.error(`Workflow execution failed: ${executionId}`, error);
      await this.executionManager.cancelExecution(executionId);
    } finally {
      // Cleanup
      this.runningExecutions.delete(executionId);
    }
  }

  /**
   * Get workflow templates with filters
   */
  async getWorkflowTemplates(filters?: {
    category?: string;
    active?: boolean;
    limit?: number;
  }): Promise<Result<WorkflowTemplate[], WorkflowEngineError>> {
    this.ensureInitialized();
    const result = await this.templateManager.getWorkflowTemplates({
      active: filters?.active,
      limit: filters?.limit,
    });

    if (result.success) {
      return { success: true, data: result.data.templates };
    }

    return result;
  }

  /**
   * Get specific workflow template by ID
   */
  async getWorkflowTemplate(
    templateId: string
  ): Promise<Result<WorkflowTemplate, WorkflowEngineError>> {
    this.ensureInitialized();
    return this.templateManager.getWorkflowTemplate(templateId);
  }

  /**
   * Check if workflow engine service is healthy
   */
  async isHealthy(): Promise<boolean> {
    try {
      if (!this.initialized) return false;

      // Check database connectivity
      await this.prisma.$queryRaw`SELECT 1`;

      // Check core modules health
      const modulesHealthy =
        this.validator &&
        this.handlerRegistry &&
        this.monitor &&
        this.templateManager &&
        this.executionManager &&
        this.stepExecutor;

      return Boolean(modulesHealthy);
    } catch (error) {
      console.error('Health check failed:', error);
      return false;
    }
  }

  /**
   * Update execution variables
   */
  private async updateExecutionVariables(
    executionId: string,
    variables: Record<string, any>
  ): Promise<void> {
    try {
      await this.prisma.workflowRun.update({
        where: { id: executionId },
        data: { variables: variables as any },
      });
    } catch (error) {
      console.error('Failed to update execution variables:', error);
    }
  }

  /**
   * Get nested value from object by path
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  /**
   * Ensure service is initialized
   */
  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new WorkflowEngineError(
        'SERVICE_NOT_INITIALIZED',
        'Workflow engine service not initialized'
      );
    }
  }

  /**
   * Cleanup and shutdown service
   */
  async shutdown(): Promise<void> {
    // Wait for all running executions to complete or timeout
    const shutdownPromises = Array.from(this.runningExecutions.values());
    await Promise.allSettled(shutdownPromises);

    this.runningExecutions.clear();
    this.initialized = false;
  }
}
