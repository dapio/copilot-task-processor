/**
 * Mock Workflow Engine Service - Refactored Main Class
 * Orchestrates workflow engine operations using modular managers
 */

import {
  WorkflowTemplate,
  WorkflowExecution,
  CreateTemplateRequest,
  UpdateTemplateRequest,
  ExecuteWorkflowRequest,
  TemplateValidationResult,
  WorkflowMetrics,
  WorkflowHealthStatus
} from '../types/workflow.types';

import { MockWorkflowTemplate, MockWorkflowExecution } from './workflow/mock/mock-types';
import { Result, ServiceError, createServiceError } from '../utils/result';
import { 
  ITemplateManager,
  IExecutionManager,
  IMonitoringManager,
  MockEngineConfig,
  MockEngineState
} from './types/mock-workflow-engine.types';

import { MockTemplateManager } from './managers/mock-template.manager';
import { MockExecutionManager } from './managers/mock-execution.manager';
import { MockConverterUtils } from './utils/mock-converter.utils';
import { MockDataStore } from './utils/mock-data.store';
import { MockTemplateFactory } from './workflow/mock/mock-template-factory';
import { MockExecutionSimulator } from './workflow/mock/mock-execution-simulator';

/**
 * Main Mock Workflow Engine Service - Refactored Architecture
 */
export class MockWorkflowEngineService {
  private readonly templateManager: ITemplateManager;
  private readonly executionManager: IExecutionManager;
  private readonly converter: MockConverterUtils;
  private readonly config: MockEngineConfig;
  private state: MockEngineState;

  constructor(config?: Partial<MockEngineConfig>) {
    this.config = {
      maxTemplates: 100,
      maxExecutions: 500,
      defaultTimeout: 300000,
      enableHealthChecks: true,
      enableStatistics: true,
      simulationDelay: 1000,
      ...config
    };

    this.converter = new MockConverterUtils();
    
    const dataStore = MockDataStore.getInstance();
    const templateFactory = new MockTemplateFactory();
    const executionSimulator = new MockExecutionSimulator();

    this.templateManager = new MockTemplateManager(dataStore, templateFactory, this.config, this.converter);
    this.executionManager = new MockExecutionManager(dataStore, executionSimulator, this.config, this.converter);

    this.state = {
      isInitialized: false,
      templateCounter: 0,
      executionCounter: 0,
      startedAt: new Date(),
      version: '1.0.0'
    };

    this.initialize();
  }

  /**
   * Initialize service with sample data
   */
  private async initialize(): Promise<void> {
    try {
      if (this.state.isInitialized) return;

      // Initialize managers
      await this.templateManager.initialize();
      await this.executionManager.initialize();

      this.state.isInitialized = true;
      this.state.templateCount = await this.templateManager.getTemplateCount();
      this.state.executionCount = await this.executionManager.getExecutionCount();

      console.log('Mock Workflow Engine initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Mock Workflow Engine:', error);
      throw error;
    }
  }

  /**
   * Create new workflow template
   */
  async createTemplate(request: CreateTemplateRequest): Promise<Result<WorkflowTemplate, ServiceError>> {
    try {
      const createResult = await this.templateManager.createTemplate(request);
      if (!createResult.success) {
        return createResult;
      }

      const workflowTemplate = this.converter.convertToWorkflowTemplate(createResult.data);
      this.state.templateCount++;

      return {
        success: true,
        data: workflowTemplate
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_CREATION_ERROR',
          `Nie udało się utworzyć szablonu: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }

  /**
   * Get template by ID
   */
  async getTemplate(templateId: string): Promise<Result<WorkflowTemplate, ServiceError>> {
    try {
      const getResult = await this.templateManager.getTemplate(templateId);
      if (!getResult.success) {
        return getResult;
      }

      const workflowTemplate = this.converter.convertToWorkflowTemplate(getResult.data);

      return {
        success: true,
        data: workflowTemplate
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_FETCH_ERROR',
          `Nie udało się pobrać szablonu: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { templateId, originalError: error }
        )
      };
    }
  }

  /**
   * Update existing template
   */
  async updateTemplate(
    templateId: string,
    request: UpdateTemplateRequest
  ): Promise<Result<WorkflowTemplate, ServiceError>> {
    try {
      const updateResult = await this.templateManager.updateTemplate(templateId, request);
      if (!updateResult.success) {
        return updateResult;
      }

      const workflowTemplate = this.converter.convertToWorkflowTemplate(updateResult.data);

      return {
        success: true,
        data: workflowTemplate
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_UPDATE_ERROR',
          `Nie udało się zaktualizować szablonu: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { templateId, originalError: error }
        )
      };
    }
  }

  /**
   * Delete template
   */
  async deleteTemplate(templateId: string): Promise<Result<boolean, ServiceError>> {
    try {
      const deleteResult = await this.templateManager.deleteTemplate(templateId);
      if (!deleteResult.success) {
        return deleteResult;
      }

      this.state.templateCount = Math.max(0, this.state.templateCount - 1);

      return {
        success: true,
        data: true
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_DELETE_ERROR',
          `Nie udało się usunąć szablonu: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { templateId, originalError: error }
        )
      };
    }
  }

  /**
   * List all templates
   */
  async listTemplates(): Promise<Result<WorkflowTemplate[], ServiceError>> {
    try {
      const listResult = await this.templateManager.listTemplates();
      if (!listResult.success) {
        return listResult;
      }

      const workflowTemplates = listResult.data.map(template => 
        this.converter.convertToWorkflowTemplate(template)
      );

      return {
        success: true,
        data: workflowTemplates
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_LIST_ERROR',
          `Nie udało się pobrać listy szablonów: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }

  /**
   * Execute workflow
   */
  async executeWorkflow(request: ExecuteWorkflowRequest): Promise<Result<WorkflowExecution, ServiceError>> {
    try {
      const executionResult = await this.executionManager.startExecution(request.templateId, request.input);
      if (!executionResult.success) {
        return executionResult;
      }

      const workflowExecution = this.converter.convertToWorkflowExecution(executionResult.data);
      this.state.executionCount++;

      return {
        success: true,
        data: workflowExecution
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_START_ERROR',
          `Nie udało się rozpocząć wykonania workflow: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { templateId: request.templateId, originalError: error }
        )
      };
    }
  }

  /**
   * Get execution status
   */
  async getExecutionStatus(executionId: string): Promise<Result<WorkflowExecution, ServiceError>> {
    try {
      const statusResult = await this.executionManager.getExecutionStatus(executionId);
      if (!statusResult.success) {
        return statusResult;
      }

      const workflowExecution = this.converter.convertToWorkflowExecution(statusResult.data);

      return {
        success: true,
        data: workflowExecution
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_STATUS_ERROR',
          `Nie udało się pobrać statusu wykonania: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { executionId, originalError: error }
        )
      };
    }
  }

  /**
   * Cancel execution
   */
  async cancelExecution(executionId: string): Promise<Result<boolean, ServiceError>> {
    try {
      const cancelResult = await this.executionManager.cancelExecution(executionId);
      if (!cancelResult.success) {
        return cancelResult;
      }

      return {
        success: true,
        data: true
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_CANCEL_ERROR',
          `Nie udało się anulować wykonania: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { executionId, originalError: error }
        )
      };
    }
  }

  /**
   * Pause execution
   */
  async pauseExecution(executionId: string): Promise<Result<boolean, ServiceError>> {
    try {
      const pauseResult = await this.executionManager.pauseExecution(executionId);
      if (!pauseResult.success) {
        return pauseResult;
      }

      return {
        success: true,
        data: true
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_PAUSE_ERROR',
          `Nie udało się wstrzymać wykonania: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { executionId, originalError: error }
        )
      };
    }
  }

  /**
   * Resume execution
   */
  async resumeExecution(executionId: string): Promise<Result<boolean, ServiceError>> {
    try {
      const resumeResult = await this.executionManager.resumeExecution(executionId);
      if (!resumeResult.success) {
        return resumeResult;
      }

      return {
        success: true,
        data: true
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_RESUME_ERROR',
          `Nie udało się wznowić wykonania: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { executionId, originalError: error }
        )
      };
    }
  }

  /**
   * List executions
   */
  async listExecutions(): Promise<Result<WorkflowExecution[], ServiceError>> {
    try {
      const listResult = await this.executionManager.listExecutions();
      if (!listResult.success) {
        return listResult;
      }

      const workflowExecutions = listResult.data.map(execution => 
        this.converter.convertToWorkflowExecution(execution)
      );

      return {
        success: true,
        data: workflowExecutions
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'EXECUTION_LIST_ERROR',
          `Nie udało się pobrać listy wykonań: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }

  /**
   * Validate template
   */
  async validateTemplate(template: WorkflowTemplate): Promise<Result<TemplateValidationResult, ServiceError>> {
    try {
      const validationResult = await this.templateManager.validateTemplate(template);
      return validationResult;
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'TEMPLATE_VALIDATION_ERROR',
          `Nie udało się zwalidować szablonu: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { templateId: template.id, originalError: error }
        )
      };
    }
  }

  /**
   * Get health status
   */
  async getHealthStatus(): Promise<Result<WorkflowHealthStatus, ServiceError>> {
    try {
      const healthResult = await this.templateManager.getHealthStatus();
      return healthResult;
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'HEALTH_CHECK_ERROR',
          `Nie udało się sprawdzić stanu zdrowia: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }

  /**
   * Get metrics
   */
  async getMetrics(): Promise<Result<WorkflowMetrics, ServiceError>> {
    try {
      const metricsResult = await this.executionManager.getMetrics();
      return metricsResult;
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'METRICS_ERROR',
          `Nie udało się pobrać metryk: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }

  /**
   * Get engine state
   */
  getEngineState(): MockEngineState {
    return {
      ...this.state,
      templateCount: this.state.templateCount,
      executionCount: this.state.executionCount
    };
  }

  /**
   * Cleanup resources
   */
  async cleanup(): Promise<Result<boolean, ServiceError>> {
    try {
      await this.templateManager.cleanup();
      await this.executionManager.cleanup();

      return {
        success: true,
        data: true
      };
    } catch (error) {
      return {
        success: false,
        error: createServiceError(
          'CLEANUP_ERROR',
          `Nie udało się wyczyścić zasobów: ${error instanceof Error ? error.message : 'Nieznany błąd'}`,
          { originalError: error }
        )
      };
    }
  }
}

/**
 * Factory function to create mock workflow engine
 */
export function createMockWorkflowEngine(config?: Partial<MockEngineConfig>): MockWorkflowEngineService {
  return new MockWorkflowEngineService(config);
}

export default MockWorkflowEngineService;